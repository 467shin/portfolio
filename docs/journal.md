# 텐서플로 / 파이토치

## 텐서플로

### 란?

- 구글에서 만들어진 딥러닝 프레임워크
- 데이터 플로우 그래프 구조를 사용
- 주로 이미지나 반복 신경망 구성, 기계 번역, 필기 숫자 판별 등을 위한 각종 신경망 학습에 사용
  -Python, C++, Go, Java, R 지원

### 장점

- 특히 대규모 예츨 모델 구성에 뛰어나 사실상 거의 모든 딥러닝 프로젝트에 범용적으로 사용할 수 있다.
- 구글에서 지원하고 있기 때문에 성능 개선과 지원에서 타 프레임워크들보다 바르고 안정적이다.
- 텐서보드(TensorBoard)를 통해서 파라미터 변화 양상이나 DNN의 구조를 알 수 있다.

### 단점

- 메모리를 효율적으로 사용하지 못 하고 있다.
- 딥러닝 모델을 만드는 데에 있어 기초 레벨부터 직접 작업해야 하기 때문에 초보자에겐 어려울 수 있다.
- 유기적으로 신경망을 만들 수 없다.

## 케라스

- 빠른 실험을 가능하게 하도록 만들어졌다.

### 란?

- 구글에서 프로젝트 연구적 노력의 목적으로 개발된 프레임워크
- 텐서플로의 문제를 해결하기 위해 보다 단순한 인터페이스를 제공
- 케라스에서 제공하는 시퀀스 모델로 원하는 레이어를 순차적으로 쌓을 수 있으며, 다중 출력 등 더 복잡한 모델일 구성할 때는 케라스 함수 API를 사용하여 쉽게 구성할 수 있다.
- 딥러닝 초급자도 각자 분야에서 손쉽게 딥러닝 모델을 개발하고 활용할 수 있도록 직관적인 API를 제공한다.
- 텐서플로에서도 쓸 수 있다

### 장점

- 일반 사용 사례에 최적화된 간단하고 일관된 인터페이스를 제공한다.
- 사용자 오류에 대해 명확하고 실용적인 피드백을 제공
- 케라스의 구성 요소는 모듈 형태로, 각 모듈이 독립성을 갖기 때문에 새로운 모델을 만들 때 각 모듈을 조합해 쉽게 새로운 모델을 만들 수 있다.

### 단점

- 모듈화의 한계로 복잡한 프로젝트에 구현 범위가 다소 좁다
- 다양한 백엔드 위에서 동작하기 때문에 어떤 오류가 발생했을 때 케라스 자체의 문제인지, 백엔드의 문제인지 특정하기 어렵다
- 문서화가 제대로 되어 있지 않고 이용자의 수가 적어 참고할 곳이 부족하다.

## 파이토치

### 란?

- 토치라는 머신러닝 라이브러리를 바탕으로 만들어 진
- 페이스북의 AI 연구 팀이 개발한 파이썬 기반 오픈소스 머신러닝 라이브러리

### 장점

- 코드를 깔끔하고 직관적으로 작성할 수 있다.
- 난이도가 낮아 학습 속도가 빠르다.
- 메모리에서 연산을 하면서도 신경망 사이즈를 최적으로 바꾸면서 동작시킬 수 있어 속도 대비 빠른 최적화가 가능하다.

### 단점

- 사용자층이 얕다
- 학습에 필요한 자료와 예제를 구하기 어렵다.

## 비교

### 텐플

- 거의 모든 딥러닝 프로젝트에서 활용도가 높은 만능 프레임워크
- 딥러닝 모델을 구축하는 단계에서 기초 레벨부터 직접 만들어 나가야 하므로 초보자에게는 추천하지 않는

### 케라스

- 배우기 쉽고 모델을 구축하기 쉽다
- 오류가 발생했을 시 케라스 자체의 문제인지, 백엔드의 문제인지 알 수 없다.

### 파토

- 텐플보다 비교적 절차가 간단하고 그래프가 동적으로 변화할 수 있으며 코드 자체도 파이썬과 유사해 진입 장벽이 낮다.
- 하지만 딥러닝에 대한 이해도가 부족하거나 코딩 지식이 없으면 파이토치 또한 난이도가 높다
- 비교적 디테일한 모델링이 불가능하다.

## 정리

- 딥러닝 입문자는 케라스 -> 파이토치 -> 텐서플로 순으로 공부하면 좋다.

---

# 코드 옵티마이제이션

- 이번 시간에는 기업에서 요구하는 기본 소양인 코드 최적화에 대해서 알아보겠습니다.

## 중요한 이유

- 성능이 곧 매출과 직결된다

## 웹 성능 결정 요소

### 로딩 성능

- 웹 페이지에 필요한 HTML, CSS, Javascript, 미디어 소스(Image, Video) 등의 리소스를 다운로드할 때의 성능
- 네트워크 요청, 자원 로딩, 브라우저의 파싱 및 렌더링 전에 필요한 처리 단계가 얼마나 걸리나

### 렌더링 성능

- 다운로드한 리소스를 가지고 화면을 그릴 때의 성능 (코드를 실행하여 화면에 보여주는 과정)
- JavaScript 실행, CSS 스타일링 및 렌더 트리 구축이 얼마나 걸리나

## 네트워크 용량 최적화

- 웹 페이지가 요청하는 모든 파일(HTML, CSS, JavaScript, 이미지 등)은 개별 HTTP 요청으로 처리된다.
- 페이지가 보다 많은 요청을 수행할수록 로딩 시간이 더 오래 걸립니다.
- 파일 번들링, 데이터 URL을 사용하여 이미지를 인라인으로 삽입하거나 작은 이미지에 대해 CSS 스프라이트를 사용하는 것으로 요청 수를 줄일 수 있습니다.

### 웹 페이지 로드 최적화

- 리소스 수 줄이기

  - **캐싱**
  - **번들링** : 번들링은 여러 작은 파일을 하나의 큰 파일로 결합하는 과정입니다. 이를 통해 브라우저가 수행해야 하는 HTTP 요청 수가 줄어들어 페이지 로드 시간이 빨라집니다.
  - **이미지 스프라이트**
    - 이미지가 다수 사용되는 웹 서비스에서 여러 이미지를 하나의 이미지로 결합하여 로딩 및 표시 효율을 높이는 기법
    - 이미지를 하나로 결합한 다음 한 번의 요청으로 리소스를 가져와 background-position 속성으로 원하는 부분만 표시하는 기법
  - **이미지 지연 로딩**
    - 이미지가 다수 사용되는 웹 서비스에서 모든 이미지를 초기에 한 번에 로드하는 것이 사용자에게 부담이 될 때 사용되는 기법
    - 사용자의 화면에 보이는 이미지만 요청하고 사용자가 스크롤을 내려 다른 이미지가 보여야 할 때마다 이미지를 요청하는 방식으로 이루어진다.

- 리소스 용량 줄이기

  - **이미지 압축**
    - 시각적인 품질이 중요치 않다면 png보다는 더 작은 jpg, jpeg를 사용한다.
    - 애니메이션이 필요한 경우 gif보다는 video 태그로 mp4파일을 사용하여 적은 용량의 리소스를 요청할 수 있다.
  - **CSS 최적화** : 간결한 셀렉터 사용, 공통 스타일은 class로 정의하여 사용
  - **최소화** : 최소화는 코드에서 불필요한 데이터(공백, 줄 바꿈 문자, 주석, 블록 구분자 등)를 제거하는 것으로 코드의 크기를 줄이고 다운로드 시간을 단축시킵니다.
  - tab size는 2 space로
  - **트리 쉐이킹** : 외부 모듈에서 필요한 기능만 임포트하는 것
  - 압축 및 난독화를 통해 용량을 최소화 한다(신입에겐 비추천)

- 블록 차단 리소스 최소화
  - HTML 파일을 파싱할 때 CSS나 JS 코드를 만나면 HTML 파싱을 중단하고 해당 파일을 파싱하거나 다운로드 후 실행하게 되는데, 이를 블록 차단 리소스라 한다.
  - 이는 곧 렌더링 차단이기 때문에 올바른 실행 위치에 코드를 작성해야 한다.
    - CSS는 head 태그의 안에 임포트 해야 하며
    - JS는 body태그의 맨 마지막에 위치시켜야 한다.
- 코드 분할을 통한 지연 로딩(코드 스플리팅)

### 웹 페이지 렌더링 최적화

- 코드 최적화

- DOM 트리와 style 트리 간결화

  - 페이지에 불필요한 요소 제거(비활성 버튼)
  - 불필요한 wrapper 사용 지양

- 레이아웃 재계산 최소화

  - CSS 속성 중에서 레이아웃을 재계산하는 속성(예: top, left, width, height)을 최소화하며 대신 transform 및 opacity와 같은 속성을 사용하여 페이지 레이아웃을 최적화

- 인라인 스타일 지양

  - 캐싱이 되지 않는 HTML 문서 내에 인라인 스타일을 사용하는 것을 피하고, 대신 외부 CSS 파일을 사용하여 스타일을 관리하세요.

## 해결 방안

### 크롬 개발자 도구 Lighthouse 패널 사용

---

## 일반적인 프론트엔드 최적화 방식

- 이미지 압축
- 최소화 : 최소화는 코드에서 불필요한 데이터(공백, 줄 바꿈 문자, 주석, 블록 구분자 등)를 제거하는 과정입니다. 이는 코드의 크기를 줄이고 다운로드 시간을 단축시킵니다.
- 번들링 : 번들링은 여러 작은 파일을 하나의 큰 파일로 결합하는 과정입니다. 이를 통해 브라우저가 수행해야 하는 HTTP 요청 수가 줄어들어 페이지 로드 시간이 빨라집니다.

- 네트워크 용량 최적화 : 페이지가 수행하는 요청 수를 줄여 페이지 로드 시간을 단축
- 브라우저 캐싱 : 파일에 대한 적절한 캐싱 정책을 지정하여 브라우저가 리소스를 캐시하도록 지시하여 다음 방문 시 HTTP 요청을 줄임
